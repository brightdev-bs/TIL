# 트랜잭션
데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위를 트랜잭션이라고 한다.
데이터베이스의 상태를 변화시킨다는 것은 사용자가 받을 수 있는 결과가 언제든 달라질 수 있다는 것을 의미한다.

## 트랜잭션 ACID
원하는 결과 또는 잘못된 로직이 수행되지 않도록 하기 위해 트랜잭션에서는 4가지 특징을 가지고 있다.
1. Atomicty (원자성) : 한 트랜잭션에서 실행되는 모든 동작은 모두 실패하거나, 성공해야 한다.
2. Consistency (일관성) : 트랜잭션의 시작 전과 종료 이후의 DB의 상태가 일관적이여야 한다. (송금된 금액의 타입이 Integer였다가 String으로 바뀌면 안된다) 
3. Isolation (격리성) : 트랜잭션은 독립적으로 실행되며, 다른 트랜잭션에 영향을 주지 않는다.
4. Durability (지속성) : 트랜잭션이 성공적으로 수행되었다면 영원히 반영되어야 한다.

## 트랜잭션 전파 레벨
트랜잭션 전파 레벨은 총 7가지가 있다.
1. REQUIRED : 트랜잭션이 없다면, 새로운 트랜잭션을 생성한다.
2. REQUIRES_NEW : 부모의 트랜잭션과 상관없이 항상 새로운 트랜잭션을 생성한다.
3. SUPPORTS : 현재 트랜잭션이 있으면 이를 따라가고, 없으면 non-transactional하게 동작한다.
4. NOT_SUPPORED : non-transactional하게 실행되며, 부모 트랜잭션이 존재하면 정지한다.
5. MANDATORY : 부모 트랜잭션내에서 실행되면, 트랜잭션이 없으면 예외가 발생한다.
6. NESTED : 부모 트랜잭션에서 진행될 경우 별개로 커밋되거나 롤백된다. 부모 트랜잭션이 없는 경우에는 REQUIRED와 동일하게 동작한다.
7. NEVER : non-transactional하게 실행되며 트랜잭션이 존재하면 예외가 발생한다.


## 트랜잭션 격리 수준
1. Read Uncommitted : 커밋되지 않은 내용을 읽을 수 있다. 따라서 DB에 커밋되지 않은 데이터를 읽는 Dirty Read문제가 발생할 수 있다.
2. Read Committed : 커밋된 내용만 읽을 수 있다. 이 경우 한 트랜잭션에서 똑같은 쿼리에 대해서 다른 결과를 읽을 수 있는 Repeatable read문제가 발생한다.
3. Repeatable Read : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있다. 이런 경우 없던 데이터가 생기는 팬텀 리드 문제가 발생한다. 
하지만 undo 영역을 생성해서 데이터의 삽입과 업데이트를 관리하는 MySql inno DB의 특성상 팬텀 리드 현상이 생기지 않는다.
4. Serializable : 가장 높은 등급의 트랜잭션 격리 수준으로, 읽기 수준에도 공유 잠금을 설정하여 어떠한 트랜잭션도 상태를 바꿀 수 없다.

## 스프링의 트랜잭션
### @Transactional
스프링에서는 @Transactional 어노테이션을 통해 트랜잭션을 관리한다.
어노테이션을 메소드에 붙이게 되면 메소드의 첫 라인에 트랜잭션을 시작하는 코드를, 마지막 라인에는 커밋하고 트랜잭션을 닫는 코드를 붙여준다.

이 어노테이션은 기본적으로 프록시 패턴으로 동작하기 때문에 메서드가 private이거나 final인 경우 적용이 불가능하다. (프록시 패턴은 상속을 통해 프록시를 만든다.)
또 한 스프링 프록시는 프록시를 통해 들어오는 외부 메소드의 호출에서만 가로챌 수 있기 때문에 inner method에 적용한 트랜잭션 어노테이션은 동작하지 않는다.

#### @Transactional(readOnly = true)
트랜잭션 어노테이션에 readOnly라는 속성이 있다. 이를 선언하게 되면 데이터의 추가, 변경, 삭제가 불가능하다. 이를 선언함으로써 얻는 여러 이점이 있다. 
1. SELECT만 동작하므로 더 안전한 프로그래밍이 가능해진다.
2. 트랜잭션 ID를 따로 부여하지 않기 때문에 이에 대한 오버헤드 문제가 생기지 않는다.
3. RDBMS 스케일 아웃으로 master, slave 구조를 가지는 경우 읽기 전용인 slave를 호출하게 된다.
4. JPA를 사용하는 경우 JPA의 영속성 컨텍스트의 변경 감지 기능을 활성화 하지 않기 때문에 메모리나 성능상의 이점이 있다. 




