# 코어 자바스크립트
## Chapter 1 - 데이터 타입
### 비트와 바이트
컴퓨터는 모든 데이터를 0과 1로만 인식하며, 0 또는 1만 표현할 수 있는 하나의 메모리 조각을 비트라고 한다. 
각 비트는 고유한 식별자를 통해 접근이 가능허다. 하지만 비트 단위로 데이터에 접근하는 것을 비효율적이기 때문에 주로 바이트 단위로 여러 비트를 묶어서 표현한다.
이 때, 너무 큰 바이트 단위는 공간을 낭비하기 때문에 적정한 공간으로 묶는 것이 좋다.
예를 들어 자바, C/C++ 에서는 데이터 타입별로 할당할 메모리 영역을 2바이트, 4바이트 등으로 나누어 놓고 있다.

### 자바스크립트의 메모리 할당
   메모리 용량이 과거보다 커진 상황에서 등장한 자바스크립트는 상대적으로 메모리 공간을 넉넉하게 할당하고 있다. 
   숫자의 경우 정수형, 부동소수형 구분 없이 8바이트를 확보하고 있기 때문에 개발자가 형변환을 걱정해야 하는 일이 적어졌다.
   
### 변수 선언과 할당 
데이터는 '변수 영역'과 '데이터 영역'으로 구분된다. `var a = 'abc';`가 메모리에 저장되는 과정을 살펴보자.
1. 변수 영역에서 빈 공간을 찾아 a라고 할당한다.
2. 데이터 영역의 빈 공간을 찾아 'abc'라는 값을 햘당한다.
3. 변수 영역의 a라는 식별자를 검색해서 주소를 찾는다. 
4. 찾은 주소를 데이터 영역에 할당한다. 

~~~java
// 변수 영역
        -------------
addr   |    1001     |
data   |    이름: c   |
       |    값: @1    |
        -------------

// 데이터 영역
        -------------
addr   |      1      |
data   |     abc     |
        -------------
~~~

 - 데이터 영역에 저장된 값은 모두 불변값이다.
 - 변수 영역의 데이터에는 다른 값을 얼마든지 대입할 수 있다. 이 부분에서 참조형 데이터는 가변값이다라고 표현 되기도 한다.
~~~java
// var obj = {
//    a : 10,
//    d : 'ddd'
// }

// 변수 영역                      객체 3001 영역
        -------------          ------------------
addr   |    3000     |        |       3001       |
data   | 이름: obj2   |        |    이름:  obj     |
       |  값 : @2     |        |      값: @2      |         
        -------------          ------------------

// 데이터 영역
        -----------------------------------------------------------------------
addr   |      1      |        2        |        1000       |        1001      |
data   |    @3001    |    @1000 ~ ?    |         10        |        ddd       |
        -----------------------------------------------------------------------
~~~
 데이터 영역의 1000번지 값을 20으로 바꾸어도 변수 영역 3000번과 3001번의 값이 달라지지 않는다. 
 
### 얉은 복사와 깊은 복사 
 - 얉은 복사는 바로 아래 단계의 값만 복사하는 방법으로, 중첩된 객체에서 참조형 데이터가 저장된 프로퍼티를 복사할 때 주소값만 복사한다.
 - 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사한다.
 - 깊은 복사 코드 1

~~~javascript
let copyObjectDeep = function (target) {
    var result = {};
    if (typeof  target === 'object' && target !== null) {
        for(const prop in target) {
            result[prop] = copyObjectDeep(target[prop]);
        }
    } else {
        result = target;
    }
    return result;
}
~~~
 - 깊은 복사 코드2 : HttpRequest로 받은 데이터를 저장한 객체를 복사할 때 유용하다.

~~~javascript
let copyObjectViaJson = function (target) {
    return JSON.parse(JSON.stringify(target));
};
~~~

#### 추가 학습 
1. ===과 ==
2. typeof

### undefined와 null
undefined는 사용자가 명시적으로 지정할 수도 있지만 값이 존재하지 않을 때 자바스크립트 엔진이 자동으로 부여하기도 한다. 다음은 자바스크립트 엔진이 자동으로 undefined를 부여하는 경우이다.
1. 값을 대입하지 않은 변수. 즉, 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때 
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때 
3. return문이 없거나 호출되지 않는 함수의 실행 결과

~~~javascript
var a; console.log(a) // case 1

var obj = { a : 1}
console.log(obj.b) // case 2
console.log(b) // c.f ) ReferenceError: b is not definied

var func = function() {}; 
var c = func() // case 3
~~~

배열에서 '비어있는 요소'와 'undefined'를 할당한 요소는 출력 결과부터 다르다. 또 '비어있는 요소'는 순회와 관련된 많은 배열 메서드들의 순회 대상에서 제외된다.

~~~javascript
var arr = [];
arr.length = 3;
console.log(arr); // [empty x 3]

var arr2 = new Array(3);
console.log(arr2); // [empty x 3]

var arr3 = [undefined, undefined, undefined]
console.log(arr3);
~~~

자바스크립트 엔진이 제공하는 undefined과 사용자가 임의로 정의한 undefined는 혼란을 야기시키기 때문에 임의로 undefined를 정의하는 일은 없어야 하며 
만약 '비어있음'을 명시적으로 표기하고 싶을 때는 undefined가 아닌 null을 이용하면 된다. 

