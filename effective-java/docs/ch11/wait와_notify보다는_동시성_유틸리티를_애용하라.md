# wait와 notify보다는 동시성 유틸리티를 이용하라

## 고수준 동시성 유틸리티
자바 5에서 도입된 고수준의 동시성 유틸리티의 도입으로 wait과 notify를 사용할 이유가 대부분 사라졌다. wait와 notify는 올바르게 사용하기가 아주 까다로우니 고수준 동시성 유틸리티를 사용하자.
고수준 동시성 유틸리티에는 세 범주로 나눌 수 있다.
1. 실행자 프레임워크
2. 동시성 컬렉션
3. 동기화 장치


### 동시성 컬렉션 
 - List, Queue, Map 같은 표준 컬렉션 인터페이스에 동시성을 가미해 구현한 고성능 컬렉션이다. 
 - 높은 동시성에 도달하기 위해 동기화를 각자의 내부에서 수행한다. <br>
     -> 따라서 동시성 컬렉션에서 동시성을 무력화하는 건 불가능하기 때문에 여러 기본 동작을 하나의 원자적 동작으로 묶는 '상태 의존적 수정' 메서드들이 추가되었다. <br>
     -> 예를 들어 Map의 putIfAbsent(key, value) 메서드는 주어진 키에 매핑된 값이 아직 없을 때만 새 값을 집어넣는다. 그리고 기존 값이 있었다면 그 값을 반환하고, 없었다면 null을 반환하다.
 - 만약 외부에서 락을 추가로 사용하면 오히려 속도가 늦어진다
 - 컬렉션 인터페이스 중 일부는 작업이 성공적으로 완료될 때까지 기다리도록 화장되었다.  <br>
     -> BlockingQueue에 추가된 메서드 중 take는 큐의 첫 원소를 끄내는데 만약 비었따면 새로운 원소가 추가될 때까지 기다린다.

### 동기화 장치
 - 스레드가 다른 스레드를 기다릴 수 있게 하여, 서로 작업을 조율할 수 있게 해준다.
 - CountDownLatch와 Semaphore가 자주 쓰인다.

#### [CountDownLatch]
   일회성 장벽으로 하나 이상의 스레드가 또 다른 하나 이상의 스레드 작업이 끝날 때까지 기다리게 한다. CountDownLatch의 유일한 생성자는 int값을 받으며,
이 값이 래치의 countDown메서드를 몇 번 호출해야 대기 중인 스레드들을 깨우는지 결정한다. 


### wait과 notify
레거시 코드에서는 어쩔 수 없이 wait과 notify를 다루어야 한다. 

#### [wait]
 - 스레드가 어떤 조건이 충족되기를 기다리게 할 때 사용한다.
 - 반드시 객체를 잠근 동기화 영역 안에서 호출해야 한다. 
 - 대기 반복문 관용구를 사용하며, 반복문 밖에서는 절대 호출하지 않는다. 
~~~java
synchronized (obj) {
    while ( 조건이 충족되지 않았다 )
        obj.wait(); // 락을 놓고, 깨어나면 다시 잡는다.
        
    ... // 조건이 충족됐을 때의 동작을 수행한다.
}
~~~
 - 대기 전에 조건을 검사하여 조건이 이미 충족되었다면 wait를 건너뛰게 한 것은 응답 불가 상태를 예방하는 조치이다.
 - 대기 후에 조건을 검사하여 조건이 충족되지 않았다면 다시 대기하게 하는 것은 안전 실패를 막는 조치이다.

조건이 만족되지 않아도 스레드가 깨어날 수 있는 상황이 몇 가지 있는데, notify와 관련되어 있다.

#### [notify]
   일반적으로는 언제나 notifyAll을 사용하는 것이 좋다. 깨어나야 하는 모든 스레드가 깨어남을 보장하니 항상 정확한 결과를 보장할 것이다. 
