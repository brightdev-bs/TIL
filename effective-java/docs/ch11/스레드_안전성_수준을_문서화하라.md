# 스레드 안전성 수준을 문서화하라
한 메서드를 여러 스레드가 동시에 호출할 때 그 메서드가 어떻게 동작하느냐는 해당 클래스와 이를 사용하는 클라이언트 사이의 중요한 계약과 같다.

## API 문서의 synchronized
   API 문서에 ssynchronized 한정자가 보이는 메서드는 스레드 안전하다는 이야기는 틀렸다. 
   자바독이 기본 옵션에서 생성한 API 문서에는 synchronized 한정자가 포함되지 않는다. 
   이는 메서드 선언에 synchronized 힌정자를 선언할지는 구현 이슈일 뿐 API에 속하지 않기 때문이다. 
   

### 스레드 안전성 수준
멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 정확히 명시해야 한다.
1. 불변 : 이 클래스의 인스턴스는 마치 상수와 같아서 외부 동기화도 필요 없다. 
2. 무조건적 스레드 안전 : 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 별도의 외부 동기화 없이 동시에 사용해도 안전하다.
3. 조건부 스레드 안전 : 무조건적 스레드 안전과 같으나, 일부 메서드는 동시에 사용하려면 외부 동기화가 피룡하다 
4. 스레드 안전하지 않음 : 이 클래스의 인스턴스는 수정될 수 있다. 동시에 사용하려면 각각의 메서드 호출을 클라이언트가 선택한 외부 동기화 매커니즘으로 감싸야 한다.
5. 스레드 적대적 : 이 클래스는 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다.

조건부 스레드 안전한 클래스는 주의해서 문서화해야 한다. 어떤 순서로 호출할 때 외부 동기화가 필요한지, 그리고 그 순서로 호출하려면 어떤 락 혹은 락들을 얻어야 하는지
알려줘야 한다. 

## 비공개 락 객체
클래스가 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있다. 하지만 내부에서 처리하는 고성능 동시성 제어 메커니즘과 혼용할 수 없게 된다.
또한 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있다. 이를 막기 위해 synchronized 대신 비공개 락 객체를 사용할 수 있다. 
~~~java
private final Object lock = new Object();

public void foo() {
    synchronized(lock) {
        ...
    }
}
~~~
비공개 락 객체는 클래스 바깥에서는 볼 수 없으니 클라이언트가 그 객체의 동기화에 관여할 수 없다. 