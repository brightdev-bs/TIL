# Serializable을 구현할지는 신중히 결정하라
어떤 클래스의 인스턴스를 직려화할 수 있게 하려면 클래스 선언에 `implements Serializable`만 붙이면 된다. 직렬화를 하기는 정말 쉽지만, 길게 보면 아주 값비싼 일이다.

## Seriazliable의 다양한 문제

### 릴리스한 뒤에는 수정이 어렵다 
 - 클래스가 Serializable을 구현하면 직렬화된 바이트 스트림 인코딩(직렬화 형태)도 하나의 공개 API가 된다.
 - 테스트할 것이 늘어난다.
 - 모든 직렬화 된 클래스에는 고유 식별 번홀르 부여 받는데, 이 번호는 클래스의 모든 정보를 고려한 해싱 방법으로 생성된다. (글자 하나만 달라져도 해시값이 달라진다)

### 버그와 보안에 위험이 생긴다
- 객체는 생성자를 만드는 게 기본이다. 하지만 역직렬화는 일반 생성자의 문제가 그대로 적용되는 '숨은 생성자'이다.
- 불변식 깨짐과 허가되지 않은 접근에 쉽게 노출된다.
     - 생성자에서 구축한 불변식을 모두 보장해야 하고 생성 도중 공격자가 객체 내부를 들여다 볼 수 없도록 해야 한다.


## Serializable의 이득과 비용을 잘 판단하자
역사적으로 BigInteger와 Instant와 같은 '값' 클래스와 컬렉션 클래스들은 Serializable을 구현하고, 스레드 풀처럼 '동작'하는 객체를 표현하는 클래스들은 대부분 구현하지 않았다. 

### 상속용으로 설계된 클래스는 Serializable을 구현하지 말자
 - 인터페이스와 상속용으로 설계된 클래스는 대부분 Serializable을 구현하지 말아야 한다.

### 직렬화와 확장이 모두 가능한 클래스인 경우
 - 인스턴스 필드 값 중 불변식을 보장해야 할 게 있다면 반드시 하위 클래스에서 finalize 메서드를 재정의하지 못하게 하자. 
 - 인스턴스 필드 중 기본값으로 초기화되면 위배되는 불변식이 있다면 클래스에 다음의 readObjectNoData 메서드를 반드시 추가하자.

~~~java
private void readObjectNoDate() throws InvalidObjectException {
    throw new InvalidObjectException("스트림 데이터가 필요합니다.");    
}
~~~

## Serializable을 구현하지 않을 때 주의점
1. 상속용 클래스인데 직렬화를 지원하지 않으면 그 하위 클래스에서 직렬화를 지원하려 할 때 부담이 늘어난다.
   - 역직렬화하려면 상위 클래스는 매개변수가 없는 생성자를 제공해야 하는데, 여러분이 이런 생성자를 제공하지 않으면 하위 클래스에서 직렬화 프록시 패턴을 사용해야 한다
2. 내부 클래스는 직렬화를 구현하지 말아야 한다.
   - 내부 클래스에는 바깥 인스턴스의 참조와 유효 범위 안의 지역변수 값들을 저장하기 위해 컴파일러가 생성한 필드들이 자동으로 추가되는데 이러한 필드들은 직렬화 형태가 분명하지 않다.
   - 단 정적 멤버 클래스는 구현해도 된다.