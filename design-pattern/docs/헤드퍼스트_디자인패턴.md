# 헤드퍼스트 디자인 패턴
## 소프트웨어 개발 불변의 진리
 > 모든 프로그램은 시간이 지남에 따라 변화한다.

### 디자인 원칙
1. 애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.
   - 달라지는 부분을 찾아서 '캡슐화'한다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
3. 상속보다는 구성을 활용한다.
   - 나는 행동을 담당하는 클래스(FlyBehavior)를 상속받는 대신 Duck클래스 안에 선언한다.

## 디자인 패턴
### [전략 패턴](../src/headfirst/strategypattern)
 - 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 준다. 
     - Flyable, Quackable 인터페이스를 상속한 FlyNoWay, MuteQuack 관계를 살펴보자.
     - 여기서 알고리즘군은 Flyable(하늘을 나는 행위), Quackable(우는 행위)가 되며 캡슐화한다는 것은 인터페이스를 작성했음을 의미한다.
 - 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
     - Duck의 나는 행위, 우는 행위를 유연하게 변경할 수 있다.
     - e.g Duck이 울지 않게 하거나, 아이어맨 슈트를 이용해 Duck을 날게 만들 수 있다. 

   
### [옵저버 패턴](../src/headfirst/observer)
 - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 알리고 이 정보를 갱신하는 방식으로 일대다 의존성을 가지고 있다.
     - 주제와 옵저버로 구성되어 있으며, 주제의 상태가 바뀌면 옵저버에게 이를 알린다.
     - 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현하는 것이 일반적이다.
 - **느슨한 결합**을 통해 유연성이 좋아진 대표적인 예이다. 
     - 주제는 옵저버가 특정 인터페이스를 구현한다는 시살만 알고 있다. (Observer 클래스)
     - 옵저버는 언제든지 새로 추가할 수 있다.
     - 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없다. 
     - 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
     - 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않는다. 
 - 옵저버가 주제로부터 데이터를 당겨오는 풀(pull) 방법도 있으며 대체로 더 선호된다. 