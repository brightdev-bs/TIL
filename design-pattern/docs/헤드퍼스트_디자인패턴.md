# 헤드퍼스트 디자인 패턴
## 소프트웨어 개발 불변의 진리
 > 모든 프로그램은 시간이 지남에 따라 변화한다.

### 디자인 원칙
1. 애플리케이션에서 달라지는 부분을 찾아내고 달라지지 않는 부분과 분리한다.
   - 달라지는 부분을 찾아서 '캡슐화'한다.
2. 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
3. 상속보다는 구성을 활용한다.
   - 나는 행동을 담당하는 클래스(FlyBehavior)를 상속받는 대신 Duck클래스 안에 선언한다.
4. 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.(OCP)
5. 추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.

## 디자인 패턴
### [전략 패턴](../src/headfirst/strategypattern)
 - 알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 준다. 
     - Flyable, Quackable 인터페이스를 상속한 FlyNoWay, MuteQuack 관계를 살펴보자.
     - 여기서 알고리즘군은 Flyable(하늘을 나는 행위), Quackable(우는 행위)가 되며 캡슐화한다는 것은 인터페이스를 작성했음을 의미한다.
 - 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있다.
     - Duck의 나는 행위, 우는 행위를 유연하게 변경할 수 있다.
     - e.g Duck이 울지 않게 하거나, 아이어맨 슈트를 이용해 Duck을 날게 만들 수 있다. 

   
### [옵저버 패턴](../src/headfirst/observer)
 - 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 알리고 이 정보를 갱신하는 방식으로 일대다 의존성을 가지고 있다.
     - 주제와 옵저버로 구성되어 있으며, 주제의 상태가 바뀌면 옵저버에게 이를 알린다.
     - 주제 인터페이스와 옵저버 인터페이스가 들어있는 클래스 디자인으로 구현하는 것이 일반적이다.
 - **느슨한 결합**을 통해 유연성이 좋아진 대표적인 예이다. 
     - 주제는 옵저버가 특정 인터페이스를 구현한다는 시살만 알고 있다. (Observer 클래스)
     - 옵저버는 언제든지 새로 추가할 수 있다.
     - 새로운 형식의 옵저버를 추가할 때도 주제를 변경할 필요가 전혀 없다. 
     - 주제와 옵저버는 서로 독립적으로 재사용할 수 있다.
     - 주제나 옵저버가 달라져도 서로에게 영향을 미치지 않는다. 
 - 옵저버가 주제로부터 데이터를 당겨오는 풀(pull) 방법도 있으며 대체로 더 선호된다. 

### [데코레이터 패턴](../src/headfirst/decorator)
 - 객체에 추가 요소를 동적으로 더할 수 있으며, 서브클래스를 만들 때보다 훨씬 유연ㅇ하게 기능을 확장할 수 있다.
 - 상속을 사용한다고 무조건 유연하거나 관리하기 쉬운 디자인이 만들어지지 않는다. 
    - 첨가물이 추가될 때마다 새로운 메소드를 추가해야 한다.
    - 특정 음료에는 추가되지 않아야 할 첨가물이 있는데, 관련 첨가물 메서드가 포함되는 문제가 있다.
 - 재사용이라는 목표를 달성하기 위해 **구성**과 **위임**으로 실행 중에 행동을 결정할 수 있다.
    - 데코레이터 클래스의 형식은 그 클래스가 감싸는 클래스 형식을 반영한다. (상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가진다.)
    - 객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 클래스를 만들고 기능을 추가할 수 있다.
    - 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없다. 
    - 자잘한 객체가 매우 많이 추가될 수 있고, 코드가 필요 이상으로 복잡해질 가능성이 있다.

### [팩토리 패턴]
 - 여러개의 구상 클래스가 있는 경우 인스턴스의 타입은 실행 시에 주어진 조건에 따라 결정되기 때문에 코드가 지저분해 질 수 있다.

~~~java
Duck duck;
if(picnic) {
    duck = new MallardDuck();
} else if(hunting) {
    duck = new DecoyDuck();    
}
~~~

 - 새로운 Duck이 발견되거나 사라진다면 조건문을 계속 바꿔줘야 한다. 이를 해결하기 위해 객체 생성을 처리하는 클래스 '팩토리'를 만들 수 있다.
    - 코드의 중복을 제거할 수 있고, 나중에 관리할 때도 한 군데에만 신경을 쓰면 된다.
    - 객체 인스턴스를 만들 때 인터페이스만 있으면 된다.
    - 인터페이스를 바탕으로 프로그래밍할 수 있어 유연성과 확장성이 뛰어나다. 
 - 간단하게 SimplePizzaFactory처럼 팩토리 클래스만 선언하여 사용할 수 있지만, PizzaStore안에 팩토리 메서드를 선언하여 사용하면 유연성이 더 증가한다.

### [팩토리 메서드 패턴]
 - 객체를 생성할 때 필요한 인터페이스를 만든다. 
 - 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정한다.
 - 팩토리 메서드 패턴을 사용하면 클래스 인스턴스 만드는 일을 서브클래스가 맡게 된다.
 - 팩토리 메서드 vs 팩토리 정적 메서드 <br> 
    -> 정적 메소드를 쓰면 객체 생성 메서드를 실행하려고 객체의 인스턴스를 만들지 않아도 된다. 하지만 서브클래스를 만들어서 객체 생성 메서드의 행동을 변경할 수 없다는 단점이 있다.

### [추상 팩토리 패턴]
 - 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생산하는 인터페이스를 제공한다. 구상 클래스는 서브클래스에서 만든다.
    - e.g 뉴욕에서는 얇은 도우를 이용, 시카고에서는 두꺼운 도우를 이용하는 경우
    - PizzaIngredientFactory 인터페이스를 정의하고 NYPizzaIngredientFactory에서 이를 구현한다.

### [싱글턴 패턴] 
 - 클래스의 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근 제공함으로써 모든 클래스에서 같은 인스턴스를 사용하게 만든다.

1. 간단하지만 문제가 있는 싱글턴
   - 멀티 쓰레드 상태에서 문제가 된다.
~~~java
public class Singleton {
    private static Singleton INSTANCE;
    
    private Singleton();
    
    public static Singleton getInstance() {
        if(INSTANCE == null) INSTANCE = new Singleton();
       return INSTANCE;
    }
}
~~~

2. 멀티쓰레드에서 안전하지만 속도가 느린 싱글턴
   - 메소드를 동기화하면 성능이 100배 정도 저하된다.
~~~java
public class Singleton {
    private static Singleton INSTANCE;
    
    private Singleton();
    
    public static synchronized Singleton getInstance() {
        if(INSTANCE == null) INSTANCE = new Singleton();
       return INSTANCE;
    }
}
~~~
   - 처음부터 인스턴스를 생성한다. 
~~~java
public class Singleton {
    private static Singleton INSTANCE = new Singleton();
    ...
}
~~~

3. DCL(Double-Checked Locking) 
   - 인스턴스가 생성되어 있는지 확인한 다음 생성되지 않았을 때만 동기화할 수 있다.
   - 자바 1.4이전에서는 volatile 키워드를 써도 DCL에서 동기화 되지 않을 수 있다.
   - 리플렉션, 직렬화, 역직렬화를 같이 사용할 경우 문제가 될 수 있다.
~~~java
public class Singleton {
   private volatile static Singleton INSTANCE;

   private Singleton();

   public static synchronized Singleton getInstance() {
      if(INSTANCE == null) {
          synchronized (Singleton.class) {
              if(INSTANCE == null)
                 INSTANCE = new Singleton();   
          }
      }
      return INSTANCE;
   }
}
~~~
   
#### volatile (추가학습)
 - volatile 키워드는 변수를 Main Memory에 저장하고 접근하여 데이터를 가져온다. 
 - 간단하게 모든 데이터를 메인 메모리에서 가져온다고 생각할 수 있지만, 메인 메모리와 프로세서 사이에 캐시가 존재한다.
 - CPU는 값을 읽어올 때 우선 캐시에 해당 값이 있는지 확인하고, 없는 경우에만 메인 메모리에서 읽어온다.
 - 락을 걸었음에도 다른 스레드가 캐시에 접근한 경우 제대로 된 동기화가 되지 않을 수 있다.
 - volatile은 많은 리소스를 잡아 먹지 않기 때문에 권장 사용된다. 

4. enum을 통한 싱글턴 생성
 - 싱글턴을 만드는 가장 이상적인 방법이다.
~~~java
public enum Singleton {
    UNIQUE_INSTANCE;
}

public class SingletonClient {
    public static void main(String[] args) {
        Singleton singleton = Singleton.UNIQUE_INSTANCE;
    }
}
~~~

### [커맨드 패턴](../src/headfirst/command)
 - 작업을 요청하는 쪽과 그 작업을 처리하는 쪽을 분리하는 패턴 
 - 커맨드 객체를 구현한 구현 클래스가 많아지는 문제가 있을 수 있는데 람다식을 사용하면 클래스를 줄일 수 있다.
~~~java
RemoteControl remoteControl = new RemoteControl();
Light livingRoomLight = new Light("Living Room");

LightOnCommand livingRoomLightOn  new LightOnCommand(livingRoomLight);
LightOffCommand livingRoomLightOff  new LightOffCommand(livingRoomLight);

remoteControl.setCommand(0, () -> livingRoomLight.on(), livingRoomLight.off());
~~~

### [어댑터 패턴](../src/headfirst/adapter)
 - 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다. 
     - 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.
     - 한국 전원 코드를 일본 콘센트에 꽂으려면 어댑터가 필요하다. 이처럼 한국 전원 코드를 일본 콘센트에 꽂을 수 있도록 해주는 것을 어댑터라고 한다.
